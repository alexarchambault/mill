package build.runner
// imports
import mill._
import mill.contrib.buildinfo.BuildInfo
object `package` extends RootModule with build.MillPublishScalaModule {
  object client extends build.MillPublishScalaModule with BuildInfo {
    // Disable scalafix because it seems to misbehave and cause
    // spurious errors when there are mixed Java/Scala sources
    def fix(args: String*): Command[Unit] = Task.Command {}
    def buildInfoPackageName = "mill.runner.client"
    def moduleDeps = Seq(build.main.client)
    def ivyDeps = Agg(
      build.Deps.nativeTerminal,
      build.Deps.coursier,
      build.Deps.coursierInterface,
      build.Deps.coursierJvm,
      build.Deps.logback,
      build.Deps.osLibWatch
    )
    def buildInfoObjectName = "Versions"
    def buildInfoMembers = Task {
      val jlineNativeVersion = compileClasspath().map(_.path.last)
        .find(name => name.startsWith("jline-native-") && name.endsWith(".jar"))
        .map(_.stripPrefix("jline-native-").stripSuffix(".jar"))
        .getOrElse {
          sys.error("Cannot get jline-native version from compile class path")
        }
      Seq(
        BuildInfo.Value("coursierJvmIndexVersion", build.Deps.coursierJvmIndexVersion),
        BuildInfo.Value("jlineNativeVersion", jlineNativeVersion)
      )
    }
  }

  def moduleDeps = Seq(
    build.scalalib,
    build.kotlinlib,
    build.scalajslib,
    build.scalanativelib,
    build.javascriptlib,
    build.pythonlib,
    build.bsp,
    linenumbers,
    build.main.codesig,
    build.main.server,
    client
  )

  object linenumbers extends build.MillPublishScalaModule {
    def moduleDeps = Seq(build.main.client)
    def scalaVersion = build.Deps.scalaVersion
    def ivyDeps = Agg(build.Deps.scalaCompiler(scalaVersion()))
  }
}
